import * as fs from 'fs';
export namespace BacktraceStackTrace {
  /**
   * Analyse stack trace generated by exception
   * Create Stack Frames and find calling library/program informaiton
   */
  export class BacktraceStackTrace {
    private readonly stackLineRe = /\s+at (.+) \((.+):(\d+):(\d+)\)/;
    public readonly fault: boolean = true;
    public readonly name = 'main';
    public stack: BacktraceStackFrame[] = [];

    private callingModulePath = '';

    constructor(err: Error | string) {
      // handle reports with message
      if (!(err instanceof Error)) {
        err = new Error();
      }
      this.parseStackFrames(err.stack);
    }

    public getCallingModulePath(): string {
      //handle a situation when every one stack frame is from node_modules
      if (!this.callingModulePath) {
        this.callingModulePath = this.stack[0].sourceCodePath;
      }
      return this.callingModulePath;
    }

    public toJson() {
      return {
        name: this.name,
        fault: this.fault,
        stack: this.stack,
      };
    }
    private parseStackFrames(stackTrace: string | undefined): void {
      if (!stackTrace) {
        return;
      }
      //get exception lines and remove first line of descrtiption
      const lines = stackTrace.split('\n').slice(1);
      lines.forEach(line => {
        const match = line.match(this.stackLineRe);
        if (!match) {
          return;
        }

        const stackFrame = {
          funcName: match[1],
          sourceCodePath: match[2],
          library: match[2],
          line: parseInt(match[3], 10),
          column: parseInt(match[4], 10),
        } as BacktraceStackFrame;

        if (this.isCallingModule(stackFrame)) {
          this.callingModulePath = stackFrame.sourceCodePath;
        }
        // todo:
        // filter backtrace-node stack frames
        this.stack.push(stackFrame);
      });
    }

    private isCallingModule(stackFrame: BacktraceStackFrame): boolean {
      return (
        !this.callingModulePath &&
        fs.existsSync(stackFrame.sourceCodePath) &&
        !stackFrame.sourceCodePath.includes('node_modules')
      );
    }
  }

  /**
   * Reprresent single stack frame in stack trace
   */
  export class BacktraceStackFrame {
    public funcName!: string;
    public sourceCodePath!: string;
    public library!: string;
    public line!: number;
    public column!: number;
  }
}
